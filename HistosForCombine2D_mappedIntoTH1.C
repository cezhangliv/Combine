#include <cstdio>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <iostream>
#include "TFile.h"
#include <TCanvas.h>
#include <TRandom.h>
#include <TRandom3.h>
#include <TMinuit.h>
#include "TH1.h"
#include "TF1.h"
#include "Riostream.h"
#include "TGraphErrors.h"
#include "TROOT.h"
#include "TStyle.h"
#include <TH2.h>
#include <TH2F.h>
#include <TH3.h>
#include <TH3F.h>
#include "TF2.h"
#include "TGraph2D.h"
#include "TMath.h"
#include "TFitter.h"
#include <string>
#include <iomanip>

//*************   CHANGE THE PATH TO THE mue CODE LOCATION   **********
//#include "/eos/user/r/rpilato/Analysis_MuE/Syst_Ebeam_Codice/mue/code/MuEtree.h"
//#include "/home/riccardo/Scrivania/MUonE/Analysis/Syst_Ebeam_Codice/mue/code/MuEtree.h"
//#include "/path/to/the/directory/of/mue/code/MuEtree.h"
#include "/user/cezhang/Soft/mue/code/MuEtree.h"

#define SAVE 1


//production of 1D histograms with a data format which could be used by combine:
//produce a root file containing the pseudodata (data_obs) and the templates (ebeam_template$i) in the directory signal_templates.
//The datacard is implemented such that combine makes ntempl fits between the pseudodata and a specific template (a separate file loops over the templates).
//combine returns then the value of lnL at the minimum in a roofit workspace. Once all the fits have been performed, you can get the values of lnL
//from the workspaces. Then, you can plot -2lnL and interpolate to obtain the best fit value.
//(this latter operation is performed in a separate root macro)



//no ratio and no normalization: use the 1D histogram as it is and compare it with the templates.
//just change the bin errors such that they are from a Poisson distribution (as for unweighted events)



//PID = 0: thL_thR (no particle identification)
//PID = 1: thmu_the
//
//energycut = 0: no
//energycut = 1: Ee > 20 GeV
//energycut = 2: cut on phi (mesmer definition of acoplanarity)


//NTOY < 0: don't smear the pseudodata

//examples for the "angular_cuts" string:
//	no PID: thmu[minAngle]_the[maxAngle]			 	angles in mrad
//	   PID: thL[minAngle]-[maxAngle]_thR[minAngle]-[maxAngle] 	angles in mrad
void HistosForCombine2D_mappedIntoTH1(int NTOY, TString angular_cuts) {

	//determine if you want to perform the fit with particle identification or not.
	//determine the selection cuts on the two scattering angles.
	bool PID = 0;
	Double_t cutThL_low  = -10;
	Double_t cutThL_high = -10;
	Double_t cutThR_low  = -10;
	Double_t cutThR_high = -10;

	if(angular_cuts.SubString("thL") == "") {
		PID = 1;
		sscanf(angular_cuts, "thmu%lf_the%lf", &cutThL_low, &cutThR_high);
		cutThL_high = 6;
		cutThR_low  = 0;
	}
	else {
		PID = 0;
		sscanf(angular_cuts, "thL%lf-%lf_thR%lf-%lf", &cutThL_low, &cutThL_high, &cutThR_low, &cutThR_high);
	}

	//set the seed for this toy
	gRandom->SetSeed(NTOY+10);

	//some settings related to data selection
	Double_t NentriesCut = 0;
	Double_t RelativeUncertaintyCut = 1;
	Int_t    energyCut = 0;

	//settings related to the templates
	Double_t Kref   = 0.13726;
	Double_t Mref   = 0.0525;
	Double_t dKu    = 0.045;
	Double_t dMu    = 0.;
	Int_t sigmaLim  = 5;
	Int_t sigmaStep = 4;	
	Int_t ngrid     = sigmaLim*sigmaStep*2 + 1;
	
	//set the requested luminosity (3 weeks test run: 5pb-1 = 5e6 ub-1)
	Double_t TRLumi = 5e6;//ub-1




	//*****************   CHANGE mainDir WITH THE LOCATION OF THE mue OUTPUT FILE. THIS IS THE FILE WHICH CONTAINS THE HISTOGRAMS GENERATED BY THE FAST SIM
	//TString mainDir = "/eos/user/r/rpilato/Analysis_MuE/Syst_Ebeam_Codice/mue/test/FINAL_THESIS/";
	TString mainDir = "/user/cezhang/Soft/mue/test/";
	TString fileLocation = "/results.root";
	
	//*****************   CHANGE dirData WITH THE DIRECTORY CONTAINING YOUR PSEUDODATA
	//TString dirData = mainDir + "job_Ebeam150.006GeV_xX00.042925_IntrRes0.021_pseudodata/MuE/" + fileLocation;
	// true
	TString dirData = mainDir + "test_mesmer_MuE_23-01-25_11:51:40/MuE" + fileLocation;
	// deviated para
	//TString dirData = mainDir + "test_mesmer_MuE_23-01-13_15:00:04/MuE" + fileLocation;
	
	TFile *infileData = new TFile(dirData);
	if(infileData->IsOpen()) cout<<"input file opened successfully"<<endl;
	else { cout<<"where is the input file?"<<endl; return ; }

	//TString range_folder = "/STEP2_PostGraz/";
	TString range_folder = "/";


	//******************   CHANGE dirTemplate WITH THE DIRECTORY CONTAINING YOUR TEMPLATES GENERATED WITH THE NOMINAL DETECTOR MODELIZATION
	//TString dirTemplate    = mainDir + range_folder + "job_nominalTemplNEW_Ebeam150.000_xX00.043010_IntrRes0.021/MuE/" + fileLocation;
	TString dirTemplate    = mainDir + "test_mesmer_MuE_23-01-25_11:51:40/MuE" + fileLocation;
	TFile *infileTemplate = new TFile(dirTemplate);
	if(infileTemplate->IsOpen()) cout<<"input file templates opened successfully"<<endl;
	else { cout<<"where is the input file?"<<endl; return ; }

	//******************   CHANGE dirMSUp WITH THE DIRECTORY CONTAINING YOUR TEMPLATES GENERATED WITH THE MULTIPLE SCATTERING MODELIZATION SHIFTED BY +1sigma
	TString dirMSUp        = mainDir + "test_mesmer_MuE_23-01-25_10:33:52/MuE" + fileLocation;//mainDir + range_folder + "job_MSUpTemplNEWNEWNEW_Ebeam150.000_xX00.0438702_IntrRes0.021/MuE/" + fileLocation;//templates with MS+1%
	TFile *infileMSUp = new TFile(dirMSUp);
	if(infileMSUp->IsOpen()) cout<<"input file MSUP opened successfully"<<endl;
	else { cout<<"where is the input file?"<<endl; return ; }

	//******************   CHANGE dirMSDown WITH THE DIRECTORY CONTAINING YOUR TEMPLATES GENERATED WITH THE MULTIPLE SCATTERING MODELIZATION SHIFTED BY -1sigma
	TString dirMSDown      = mainDir + "test_mesmer_MuE_23-01-25_11:48:47/MuE" + fileLocation;//mainDir + range_folder + "job_MSDownTemplNEWNEWNEW_Ebeam150.000_xX00.0421498_IntrRes0.021/MuE/" + fileLocation;//templates with MS-1%
	TFile *infileMSDown = new TFile(dirMSDown);
	if(infileMSDown->IsOpen()) cout<<"input file MSDOWN opened successfully"<<endl;
	else { cout<<"where is the input file?"<<endl; return ; }




	//directories in the results.root file where to find the 2D histograms needed for the template fit (DO NOT CHANGE THIS)
	TString dir_reference;
	TString dir_lep;
	TString dir_templ;
	if(PID) {
		if(energyCut == 0) {
			dir_reference = "det/templ/NLO/full/hsn_thmuVsthe_NLO_ref";
			dir_lep       = "det/templ/NLO/lep/hsn_thmuVsthe_NLO_lep";
			dir_templ     = "det/templ/NLO/had/hsn_thmuVsthe_NLO_templ";
		}
		else {
			dir_reference = "det/templ/NLO/full/e20_hsn_thmuVsthe_NLO_ref";
			dir_lep       = "det/templ/NLO/lep/e20_hsn_thmuVsthe_NLO_lep";
			dir_templ     = "det/templ/NLO/had/e20_hsn_thmuVsthe_NLO_templ";
		}
	}
	else {
		if(energyCut == 0) {
			dir_reference = "det/templ/NLO/full/hsn_thL_vs_thR_NLO_ref";
			dir_lep       = "det/templ/NLO/lep/hsn_thL_vs_thR_NLO_lep";
			dir_templ     = "det/templ/NLO/had/hsn_thL_vs_thR_NLO_templ";
		}
		else {
			dir_reference = "det/templ/NLO/full/e20_hsn_thL_vs_thR_NLO_ref";
			dir_lep       = "det/templ/NLO/lep/e20_hsn_thL_vs_thR_NLO_lep";
			dir_templ     = "det/templ/NLO/had/e20_hsn_thL_vs_thR_NLO_templ";
		}
	}



	//get the reference and the leptonic histograms
	//nominal histograms
	TH2D *hn_thmuVsthe_NLO_ref = (TH2D*) infileData->Get(dir_reference);

	//get the template histograms
	std::vector<TH2D*> hn_thmuVsthe_NLO_templ;//nominal histograms

	std::vector<TH2D*> hn_thmuVsthe_NLO_templ_MSUp;//+1sigma histograms
	std::vector<TH2D*> hn_thmuVsthe_NLO_templ_MSDown;//-1sigma histograms


	for(int iK = 0; iK < ngrid; iK++) {
		TString histo_templ = dir_templ + Form("_K%i", iK);
		//nominal histograms
		hn_thmuVsthe_NLO_templ.push_back((TH2D*) infileTemplate->Get(histo_templ));
		if(hn_thmuVsthe_NLO_templ.back() == nullptr) { cout<<"PROBLEM: template (K) = ("<<iK<<") does not exist in infile"<<endl; return ;}

		//MS
		//+1sigma histograms
		hn_thmuVsthe_NLO_templ_MSUp.push_back((TH2D*) infileMSUp->Get(histo_templ));
		if(hn_thmuVsthe_NLO_templ_MSUp.back() == nullptr) { cout<<"PROBLEM: template (K) = ("<<iK<<") does not exist in infileMSUp"<<endl; return ;}
		//-1sigma histograms
		hn_thmuVsthe_NLO_templ_MSDown.push_back((TH2D*) infileMSDown->Get(histo_templ));
		if(hn_thmuVsthe_NLO_templ_MSDown.back() == nullptr) { cout<<"PROBLEM: template (K) = ("<<iK<<") does not exist in infileMSDown"<<endl; return ;}

	}


	//set the angular cuts
	Int_t binThR_low   = std::max(hn_thmuVsthe_NLO_ref->ProjectionX()->FindBin(cutThR_low), 1);
	Int_t binThR_high  = std::min(hn_thmuVsthe_NLO_ref->ProjectionX()->FindBin(cutThR_high), hn_thmuVsthe_NLO_ref->GetNbinsX()+1);
	Int_t binThL_low   = std::max(hn_thmuVsthe_NLO_ref->ProjectionY()->FindBin(cutThL_low), 1);
	Int_t binThL_high  = std::min(hn_thmuVsthe_NLO_ref->ProjectionY()->FindBin(cutThL_high), hn_thmuVsthe_NLO_ref->GetNbinsY()+1);
	for(int i = 1; i <= hn_thmuVsthe_NLO_ref->GetNbinsX(); i++) {
		for(int j = 1; j <= hn_thmuVsthe_NLO_ref->GetNbinsY(); j++) {
			if((i < binThR_low || i >= binThR_high) || (j < binThL_low || j >= binThL_high)) {
				//nominal histograms
				hn_thmuVsthe_NLO_ref->SetBinContent(i, j, 0);
				hn_thmuVsthe_NLO_ref->SetBinError(i, j, 0);
			
				for(int iK = 0; iK < ngrid; iK++) {
					//nominal histograms
					hn_thmuVsthe_NLO_templ[iK]->SetBinContent(i, j, 0);
					hn_thmuVsthe_NLO_templ[iK]->SetBinError(i, j, 0);

					//MS
					//+1sigma histograms
					hn_thmuVsthe_NLO_templ_MSUp[iK]->SetBinContent(i, j, 0);
					hn_thmuVsthe_NLO_templ_MSUp[iK]->SetBinError(i, j, 0);
					//-1sigma histograms
					hn_thmuVsthe_NLO_templ_MSDown[iK]->SetBinContent(i, j, 0);
					hn_thmuVsthe_NLO_templ_MSDown[iK]->SetBinError(i, j, 0);
				}
			}
		}
	}


	//define the total number of bins for the combine histogram
	Int_t nbins_tot = hn_thmuVsthe_NLO_ref->GetNbinsX()*hn_thmuVsthe_NLO_ref->GetNbinsY();


	//set the errors on data_obs according to TRLumi
	TTree *MuESetup = (TTree*) infileData->Get("MuEsetup");
	MuE::Setup *MuEparams = 0;
	MuESetup->SetBranchAddress("MuEparams", &MuEparams);

	Double_t totalEvents = 0;//ntot events from NLO file
	Double_t sigma0_tot  = 0;//ub (Wnorm from NLO file)
	for(int i = 0; i < MuESetup->GetEntries(); i++) {
		MuESetup->GetEntry(i);
		totalEvents += MuEparams->MCsums.Nevgen;//ntot events from NLO file
		sigma0_tot += MuEparams->MCpargen.Wnorm;//ub (Wnorm from NLO file)
	}
	sigma0_tot /= MuESetup->GetEntries();

	Double_t MCLumi = totalEvents/sigma0_tot;//ub-1
	cout<<"totEvents = "<<totalEvents<<" sigma0 = "<<sigma0_tot<<" MCLumi = "<<MCLumi<<endl;
	Double_t scaleFactor_data = TRLumi/MCLumi;

	//define the pseudodata 1D histogram which will be used by combine
	TH1D *data_obs_histo = new TH1D("data_obs", hn_thmuVsthe_NLO_ref->GetTitle(), nbins_tot, 0, nbins_tot);//pseudodata histogram
	//fill data_obs and set the errors
	int counter = 1;
	for(int i = 0; i < hn_thmuVsthe_NLO_ref->GetNbinsX(); i++) {
		for(int j = 0; j < hn_thmuVsthe_NLO_ref->GetNbinsY(); j++) {
			Double_t Nevents = hn_thmuVsthe_NLO_ref->GetBinContent(i+1, j+1);
			Nevents = Nevents*scaleFactor_data;
			if(Nevents > NentriesCut) {
				if(NTOY < 0) {cout<<"Hi! You are not smearing the pseudodata!"<<endl; data_obs_histo->SetBinContent(counter, Nevents);}//if NTOY < 0 don't do toys
				else data_obs_histo->SetBinContent(counter, gRandom->Gaus(Nevents, TMath::Sqrt(Nevents)));
				data_obs_histo->SetBinError(counter, TMath::Sqrt(Nevents));
			}
			else data_obs_histo->SetBinError(counter, 0);

			counter++;
		}
	}



	//set the errors on the templates
	std::vector<TH1D*> htempl;//template histograms with the nominal detector modelization
	MuESetup = (TTree*) infileTemplate->Get("MuEsetup");
	MuESetup->SetBranchAddress("MuEparams", &MuEparams);
	totalEvents = 0;
	sigma0_tot  = 0;
	for(int i = 0; i < MuESetup->GetEntries(); i++) {
		MuESetup->GetEntry(i);
		totalEvents += MuEparams->MCsums.Nevgen;//ntot events from NLO file
		sigma0_tot += MuEparams->MCpargen.Wnorm;//ub (Wnorm from NLO file)
	}
	sigma0_tot /= MuESetup->GetEntries();
	MCLumi      = totalEvents/sigma0_tot;//ub-1
	Double_t scaleFactor_templ = TRLumi/MCLumi;

	
	//MS
	std::vector<TH1D*> htempl_MSUp;//template histograms with MultipleScattering modelization shifted by +1sigma
	MuESetup = (TTree*) infileMSUp->Get("MuEsetup");
	MuESetup->SetBranchAddress("MuEparams", &MuEparams);
	totalEvents = 0;
	sigma0_tot  = 0;
	for(int i = 0; i < MuESetup->GetEntries(); i++) {
		MuESetup->GetEntry(i);
		totalEvents += MuEparams->MCsums.Nevgen;//ntot events from NLO file
		sigma0_tot += MuEparams->MCpargen.Wnorm;//ub (Wnorm from NLO file)
	}
	sigma0_tot /= MuESetup->GetEntries();
	MCLumi      = totalEvents/sigma0_tot;//ub-1
	Double_t scaleFactor_MSUp = TRLumi/MCLumi;

	std::vector<TH1D*> htempl_MSDown;//template histograms with MultipleScattering modelization shifted by -1sigma
	MuESetup = (TTree*) infileMSDown->Get("MuEsetup");
	MuESetup->SetBranchAddress("MuEparams", &MuEparams);
	totalEvents = 0;
	sigma0_tot  = 0;
	for(int i = 0; i < MuESetup->GetEntries(); i++) {
		MuESetup->GetEntry(i);
		totalEvents += MuEparams->MCsums.Nevgen;//ntot events from NLO file
		sigma0_tot += MuEparams->MCpargen.Wnorm;//ub (Wnorm from NLO file)
	}
	sigma0_tot /= MuESetup->GetEntries();
	MCLumi      = totalEvents/sigma0_tot;//ub-1
	Double_t scaleFactor_MSDown = TRLumi/MCLumi;




	//fill the templates and set the errors (...although template errors are neglected by combine...)
	for(int iK = 0; iK < ngrid; iK++) {
		htempl.push_back(new TH1D(Form("htempl_K%i", iK), hn_thmuVsthe_NLO_templ[iK]->GetTitle(), nbins_tot, 0, nbins_tot));//nominal histograms


		//MS
		htempl_MSUp.push_back(new TH1D(Form("htempl_MSUp_K%i", iK), hn_thmuVsthe_NLO_templ_MSUp[iK]->GetTitle(), nbins_tot, 0, nbins_tot));//+1sigma histograms
		htempl_MSDown.push_back(new TH1D(Form("htempl_MSDown_K%i", iK), hn_thmuVsthe_NLO_templ_MSDown[iK]->GetTitle(), nbins_tot, 0, nbins_tot));//-1sigma histograms

		
		counter = 1;
		for(int i = 0; i < hn_thmuVsthe_NLO_ref->GetNbinsX(); i++) {
			for(int j = 0; j < hn_thmuVsthe_NLO_ref->GetNbinsY(); j++) {
				//template histograms with the nominal detector modelization
				Double_t Nevents = hn_thmuVsthe_NLO_templ[iK]->GetBinContent(i+1, j+1);
				Nevents = Nevents*scaleFactor_templ;
				if(Nevents > NentriesCut) {
					htempl.back()->SetBinContent(counter, Nevents);
					htempl.back()->SetBinError(counter, TMath::Sqrt(Nevents));
				}
				else htempl.back()->SetBinError(counter, 0);

				//MS
				//template histograms with MultipleScattering modelization shifted by +1sigma
				Double_t Nevents_MSUp = hn_thmuVsthe_NLO_templ_MSUp[iK]->GetBinContent(i+1, j+1);
				Nevents_MSUp = Nevents_MSUp*scaleFactor_MSUp;
				if(Nevents_MSUp > NentriesCut) {
					htempl_MSUp.back()->SetBinContent(counter, Nevents_MSUp);
					htempl_MSUp.back()->SetBinError(counter, TMath::Sqrt(Nevents_MSUp));
				}
				else htempl_MSUp.back()->SetBinError(counter, 0);
				//template histograms with MultipleScattering modelization shifted by -1sigma
				Double_t Nevents_MSDown = hn_thmuVsthe_NLO_templ_MSDown[iK]->GetBinContent(i+1, j+1);
				Nevents_MSDown = Nevents_MSDown*scaleFactor_MSDown;
				if(Nevents_MSDown > NentriesCut) {
					htempl_MSDown.back()->SetBinContent(counter, Nevents_MSDown);
					htempl_MSDown.back()->SetBinError(counter, TMath::Sqrt(Nevents_MSDown));
				}
				else htempl_MSDown.back()->SetBinError(counter, 0);

				counter++;
			}
		}
	}


	TCanvas *c2D = new TCanvas("c2D", "", 1080, 720);
	c2D->Draw();
	c2D->SetLogz();
	hn_thmuVsthe_NLO_ref->Draw("ZCOL");



	if(SAVE == 1) {
		cout<<"Saving root file for the datacard with systematics..."<<endl;
		TFile *outfile;
		TString outfileName = Form("./toy_data_%i.root", NTOY);

		outfile = new TFile(outfileName, "RECREATE");
		
		cout<<"data_obs->Integral = "<<data_obs_histo->Integral()<<endl;
		if(!outfile->GetDirectory("signal_templates")) outfile->mkdir("signal_templates");
		outfile->cd("signal_templates");
		data_obs_histo->Write("data_obs", TObject::kOverwrite);
		for(int iK = 0; iK < ngrid; iK++) {	
			cout<<"muemue_template"<<iK<<" Integral = "<<htempl[iK]->Integral()<<endl;
			htempl[iK]->Write(Form("muemue_template%i", iK), TObject::kOverwrite);
		}

		outfile->cd("../");
		
		// +/- 1sigma histograms
		if(!outfile->GetDirectory("signal_templates_systematic")) outfile->mkdir("signal_templates_systematic");
		outfile->cd("signal_templates_systematic");
		for(int iK = 0; iK < ngrid; iK++) {
			//MS
			htempl_MSUp[iK]->Write(Form("muemue_template%i_MultipleScatteringUp", iK), TObject::kOverwrite);
			htempl_MSDown[iK]->Write(Form("muemue_template%i_MultipleScatteringDown", iK), TObject::kOverwrite);
		}
		outfile->Close();
	}


return ;
}










